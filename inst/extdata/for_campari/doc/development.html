<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
############################################################################
# LICENSE INFO:                                                            #
############################################################################
#    This file is part of CAMPARI.                                         #
#                                                                          #
#    Version 3.0                                                           #
#                                                                          #
#    Copyright (C) 2017, The CAMPARI development team (current and former  #
#                        contributors)                                     #
#                        Andreas Vitalis, Adam Steffen, Rohit Pappu, Hoang #
#                        Tran, Albert Mao, Xiaoling Wang, Jose Pulido,     #
#                        Nicholas Lyle, Nicolas Bloechliger, Marco Bacci,  #
#                        Davide Garolini, Jiri Vymetal                     #
#                                                                          #
#    Website: http://sourceforge.net/projects/campari/                     #
#                                                                          #
#    CAMPARI is free software: you can redistribute it and/or modify       #
#    it under the terms of the GNU General Public License as published by  #
#    the Free Software Foundation, either version 3 of the License, or     #
#    (at your option) any later version.                                   #
#                                                                          #
#    CAMPARI is distributed in the hope that it will be useful,            #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#    GNU General Public License for more details.                          #
#                                                                          #
#    You should have received a copy of the GNU General Public License     #
#    along with CAMPARI.  If not, see <http://www.gnu.org/licenses/>.      #
############################################################################
# AUTHORSHIP INFO:                                                         #
############################################################################
#                                                                          #
# MAIN AUTHOR:   Andreas Vitalis                                           #
# CONTRIBUTIONS: Adam Steffen                                              #
#                                                                          #
############################################################################
-->
<html xml:lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<!--
    Designed by CAMPARI Development Group
    Base template (without user's data) checked by http://validator.w3.org : "This page is valid XHTML 1.0 Transitional"
    -->
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge"></meta>
  <title>CAMPARI Development</title>
  <link rel="stylesheet" href="style_red.css" type="text/css" media="screen"></link>
</head>
<body>
<div id="art-page-background-simple-gradient"></div>
<div id="art-main"><!-- Header -->
<div class="art-Sheet2"><!-- Banner Art -->
<div class="art-Header">
<div class="art-Header-png"></div>
</div>
<!-- Top Navigation Bar -->
<div class="art-nav">
<div class="l"></div>
<div class="r"></div>
<ul class="art-menu">
  <li><a href="index.html"><span class="l"></span><span class="r"></span><span
 class="t">Home</span></a></li>
  <li><a href="documentation.html" class=" active"><span class="l"></span><span
 class="r"></span><span class="t">Documentation</span></a></li>
  <li><a href="references.html"><span class="l"></span><span class="r"></span><span
 class="t">References</span></a></li>
  <li><a href="contact.html"><span class="l"></span><span class="r"></span><span
 class="t">Support</span></a></li>
  <li><a href="download.html"><span class="l"></span><span class="r"></span><span
 class="t">Download</span></a></li>
</ul>
</div>
<!-- Top Sub Navigation Bar -->
<div class="nav-menu">
<ul class="navlist">
  <li><a href="documentation.html">Overview</a></li>
  <li><a href="install.html">Install</a></li>
  <li><a href="tutorials.html">Tutorials</a></li>
  <li><a href="inputfiles.html">Inputfiles</a></li>
  <li><a href="keywords.html">Keywords</a></li>
  <li><a href="outputfiles.html">Outputfiles</a></li>
  <li><a href="parameters.html">Parameters</a></li>
  <li><a href="development.html" class=" active">Development</a></li>
  <li><br/>
  </li>
</ul>
</div>
</div>
<!-- Main Page Contents -->
<div class="art-Sheet">
<div class="art-Sheet-bl"></div>
<div class="art-Sheet-br"></div>
<div class="art-Sheet-bc"></div>
<div class="art-Sheet-cl"></div>
<div class="art-Sheet-cr"></div>
<div class="art-Sheet-cc"></div>
<div class="art-Sheet-body">
<div class="art-contentLayout"><!-- Page Contents -->
<div class="art-content">
<div class="art-Post">
<div class="art-Post-body">
<div class="art-PostContent">
<br/>
<h2>CAMPARI Development</h2>
<ol>
  <li>&nbsp;&nbsp; <a href="development.html#Introduction_to_Campari_Source_Code">Introduction to CAMPARI Source Code</a></li>
  <li>&nbsp;&nbsp; <a href="development.html#Getting_Started">Getting Started</a></li>
  <li>&nbsp;&nbsp; <a href="development.html#navtools">Code Navigation Tools</a><br/></li>
  <li>&nbsp;&nbsp; <a href="development.html#FAQ">FAQ</a></li>
</ol>
<h3><a class="NoHi" id="Introduction_to_Campari_Source_Code">Introduction to CAMPARI Source Code</a></h3>
A priority of the CAMPARI project is to provide code that is easy
to access and can be tailored to better suit the research needs of
each user, whether it be obtaining different output, using novel
molecule types, or by introducing a new algorithm that improves
sampling. However, experience and familiarity with a code base are
indispensable to make development less and less cumbersome with time.
Therefore, at this point, we simply hope that the "average" knowledgeable
programmer familiar with Fortran will find CAMPARI adequately readable and customizable.<br/>
<br/>
CAMPARI is generally written in Fortran 90/95 but uses certain features from the Fortran 03/08 standards
(see <a href="install.html">elsewhere</a>). Version 3 relies heavily on Fortran OpenMP directives
to produce threads-parallel code.
Fortran is a language originally developed and optimized for scientific programming with many
implicit functions that are useful for algorithms in mathematics and physics.
Of course it lacks comprehensive support for many
of the features that modern code would attempt to utilize from a software
engineering point of view. Given that the target audience (researchers
in the fields ranging from molecular biology to molecular physics) will inevitably span a wide range
of programming experience and skills, it is not clear to us whether this is a caveat or 
a feature with respect to CAMPARI development. The choice of programming language
is mostly historical for this particular project. Scientific software is rarely
written by a team of dedicated software engineers over a well-defined stretch of time, but rather
evolves and adapts continuously to the needs of the researchers using it. We considered translating
CAMPARI to C++ early during development, but ultimately decided that the immediate upside
would be too limited given the high time investment necessary for such an endeavor.
We maintain that Fortran is a good language for an open source project where accessibility and readability by 
an inhomogeneous audience are priorities. In version 3, readability has become worse due to the OpenMP directives.
We recommend producing preprocessed source files (with OpenMP support removed) if developers or users are interested primarily in 
understanding what a specific part of the code does (and not how this function is parallelized).<br/>
<h3><a class="NoHi" id="Getting_Started">Getting Started</a></h3>
Depending on the complexity of the planned development and your familiarity with a code,
it may be useful to obtain a "virgin" copy of CAMPARI rather than introducing 
multiple changes to the same copy. To give you a rough idea where to start looking for things, the following overview
may be helpful:<br/>
<ul>
<li>Module files are called mod_*.f90 and hold variables and derived data type declarations. The only exception
is "<a href="../source/mod_interfaces.f90">mod_interfaces.f90</a>", which holds interfaces for basic operations
(sort, <i>etc.</i>) to support different input data types, optional arguments, or arguments with the "ALLOCATABLE" attribute. Source-files
are called *.f90 and hold subroutines. Only those modules that are needed should be "included" by each subroutine
("include" commands just below the subroutine declaration). Some modules are large, and it may help to use "ONLY" statements
with the "include" commands to avoid accidental overloading of variable names.</li>
<li>The source-files creating the actual binaries are called "<a href="../source/chainsaw.f90">chainsaw.f90</a>" and
"<a href="../source/datasaw.f90">datasaw.f90</a>". The latter is for a reduced functionality executable that provides
a flexible handle on data inputs for analysis tasks (see documentation <a href="keywords.html#netcdf_anal">elsewhere</a>).
From these drivers, you are theoretically 
able to recover the entire execution tree by tracing calls to subroutines and searching the source-files for
these subroutines. Many subroutines are nonuniversal, <i>i.e.</i>, are called only in specific executions of the program.</li>
<li>Theoretically, you can place new variables in any module file, and new subroutines in any source-file. However, we
attempt to loosely group them in intuitive blocks. Often, several subroutines are found in the same source-file. This serves to achieve a
compromise between file size and file number (which is lately tipping over to the size side). You can copy-paste existing subroutines
with similar scope and delete the actual "meat" to avoid trivial errors. The choice of having few source files is largely due to
personal preference, and nothing stops you from creating new source files or using ones that have very little in it, <i>e.g.</i>,
"<a href="../source/getkey.f90">getkey.f90</a>" during development (reduces compile time).
</li>
<li>When creating new files, make sure to append the lists in the two files "<a href="../source/Makefile">Makefile</a>" and
"<a href="../source/make_dependencies.sh">make_dependencies.sh</a>" both
found in the source-subdirectory. Otherwise they will not get compiled, and the compilation and/or linking step will fail (these lists 
are in variables called "PREPREMODS" and "PREPRESRCS" in the former and "MODULES" and "PRESOURCES" in the latter).</li>
<li>CAMPARI uses a hybrid MPI/OpenMP approach. Currently, the OpenMP (inner) layer is used to decompose tasks for a single copy
of the simulation system whereas the MPI (outer) layer handles only communication between multiple copies of the simulation system.
This means that interaction with the MPI layer is rare while interaction with the OpenMP layer is almost inevitable. OpenMP 
works through compiler-interpreted directives while MPI works through linked library calls. Essentially, the threads "library"
is completely embedded in the compiler.</li>
<li>The driver routines for MPI-based simulation schemes are called "MPI_REMaster", "MPI_ASMaster", and "MPI_AVGCollect" in
"<a href="../source/fmsmcmpi.f90">fmsmcmpi.f90</a>".</li>
<li>The team of OpenMP threads is generated only once and maintained from there on throughout the entire calculation. This happens
in "<a href="../source/chainsaw.f90">chainsaw.f90</a>" and "<a href="../source/datasaw.f90">datasaw.f90</a>" after all the initial setup.
This implies that the scope of variables for individual threads is private by default (since they encounter stack-allocated variables). Shared variables
are the ones with global scope found in the modules. The general variable to identify a thread is called "tpi" or sometimes "tpi2", and
all subroutines entered by multiple threads at once should have this argument (its presence helps clarify that the code needs to be thread-aware).</li>
<li>Many subroutines are maintained in a way that serial and threads-enabled code will execute correctly (preprocessor directives "ifdef ENABLE_THREADS").
This is beneficial for keeping the algorithms robust and results reproducible but can make for very scattered reading. It thus may be
helpful to use the preprocessor to produce processed source files for a clearer reading of either version. Other subroutines have been explicitly 
duplicated, most notably "force3_threads" in "<a href="../source/force_wrap.f90">force_wrap.f90</a>". In these cases, any additional
modifications must be made twice to maintain proper functionality. Many OpenMP-associated routines are found in "<a href="../source/thread_utils.f90">thread_utils.f90</a>".</li>
<li>From experience, it is very useful to think in parallel from the beginning for new algorithms to be added to time-consuming parts
of CAMPARI's execution path (energy, forces, neighbor searching, coordinate operations, ...). An example would be the calculation of instantaneous
pressures based on the virial. Expensive features that are exclusively serial will become a bottleneck quickly and thus have low viability in CAMPARI.</li>
<li>The top-level file containing the decision tree for picking and executing a specific Monte Carlo move is in "<a href="../source/mcmove.f90">mcmove.f90</a>".</li>
<li>The top-level subroutines containing the Newtonian leap-frog integrators in Cartesian and torsional/rigid-body space are in files "<a href="../source/cartmd.f90">cartmd.f90</a>" and "<a href="../source/intmd.f90">intmd.f90</a>", respectively. The Langevin integrator in Cartesian space is in
"<a href="../source/cartld.f90">cartld.f90</a>".</li>
<li>The majority of energy and force evaluations are based on the organizational unit of the residue. This means that interactions
are computed as residue-residue interactions. For Monte Carlo (no forces needed), the necessary wrappers are in "<a href="../source/energy_wrap.f90">energy_wrap.f90</a>",
and the actual routines in "<a href="../source/inner_loops_en.f90">inner_loops_en.f90</a>" and "<a href="../source/energy.f90">energy.f90</a>". For forces, it is slightly
less complicated on the wrapper-side ("<a href="../source/force_wrap.f90">force_wrap.f90</a>"),
but a lot more complicated on the execution side ("<a href="../source/inner_loops.f90">inner_loops.f90</a>",
"<a href="../source/inner_loops_imp.f90">inner_loops_imp.f90</a>", and "<a href="../source/force.f90">force.f90</a>"). The innermost routines
are generally expected to be executed by a single OpenMP thread at a given time. It is important that they do exploit vectorization,
however.</li>
<li>The building process for the molecules representable in CAMPARI is controlled through "<a href="../source/makepept.f90">makepept.f90</a>",
and uses the straightforward subroutines in "<a href="../source/proteus.f90">proteus.f90</a>" and "<a href="../source/sidechain.f90">sidechain.f90</a>". Many of the core algorithms related to coordinate operations/representations are found in "<a href="../source/topology.f90">topology.f90</a>". None of the initial
setup routines are OpenMP-aware and basically all are called identically by different MPI ranks.
</li>
<li>All CAMPARI-internal analysis is handled through a top-level wrapper in "<a href="../source/mcstat.f90">mcstat.f90</a>"
(see the second FAQ below for more on this).</li>
<li>After having written and compiled a new feature, we strongly recommend to use debugging options provided by the compiler you are using.
Examples of necessary flags can be found in "<a href="../source/Makefile">Makefile</a>" for several common compilers.</li>
<li>For a simplistic development environment, it will be enough to have access to a good text editor, and to use (on UNIX) simple
command line tools such as "grep" efficiently (for example to find out where specific global variable defined in one of the modules
is used). In this regard, it will also be beneficial to keep the formatting consistent with the rest of the code.</li>
<li>Lastly, it is important to keep in mind that in any complex software package, changes to one section of the code may have 
unexpected consequences on others. If you intend to see a new feature you developed incorporated permanently, it will be necessary to 
make sure most of these consequences are avoided upfront.</li>
</ul>
Unfortunately, having comprehensive in-code documentation is very difficult to
achieve, since it is not typically possible to anticipate the questions other
developers may have (for instance, it is relatively easy to provide full documentation
on the inputs and outputs for each subroutine, but in most cases that will not
help anyone understand the algorithm inside). CAMPARI is documented internally
rather inhomogeneously and usually requires a conceptual understanding of what a specific
piece of code is trying to do. It is always recommended to first consult the actual user documentation
on a feature of interest before inspecting the code itself.
In the same spirit, higher level information such as the <a href="development.html#FAQ">FAQs 
below</a> may (at least in certain cases) be an efficient means of "documenting" code.<br/>
<h3><a class="NoHi" id="navtools">Code Navigation Tools</a></h3>
Currently, the only code development tool we provide is a little python-program to help track global variables.
There is a README file that explains usage (<a href="globals_doc.readme">link</a>).
It can be found in the doc-subdirectory as a file called "<a href="typeglobals_html.py">typeglobals_html.py</a>".<br/>
When run successfully, this will create a set of html-files summarizing which subroutines access and modify
which global variables. Naturally, it assumes CAMPARI-style syntax, and may not always work 100% accurately if formatting
violations occur. The html-files produced can be very valuable for avoiding conflicts/pitfalls during development early on.<br/>
<h3><a class="NoHi" id="FAQ">FAQ</a></h3>
This is a short list of (two) questions that will occur frequently. Both deal with extending
pre-existing functionality in CAMPARI by different but at some level analogous additional
cases.<br/><br/>
<b>Q: What do I need to do and know if I want to add (permanent and complete) support for a new
small molecule, or a new polypeptide or polynucleotide residue type
which has identical backbone architecture?</b>
<br/>
<b>A</b>: This is one of the more tedious exercises in CAMPARI. Note that CAMPARI does allow
simulations and trajectory analyses of systems containing entities (residues) not natively
supported by CAMPARI (&rarr; <a href="keywords.html#PDB_TEMPLATE">FMCSC_PDB_TEMPLATE</a>
and <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>).<br/>
If permanent modification is deemed superior or preferred for any reason, then there
are a number of steps involved as follows. Importantly, there is no need to worry about
either <a href="keywords.html#NRTHREADS">OpenMP</a> or <a href="keywords.html#REMC">MPI parallelization</a>
here because all steps are during the initial execution stages where (currently) all MPI 
ranks independently perform the same tasks and no OpenMP thread have been created yet. 
<ol type="A">
  <li>
Append the biotypes section of all force field parameter files (see <a
 href="parameters.html#S1_Biotypes">dedicated section of the documentation</a>) with the necessary information
for the new residue. Note that there is freedom to make each atom its
own biotype although CAMPARI aims at summarizing chemically equivalent
atoms under a single biotype (for example in this convention, propane
has only four biotypes). While you are at it, assign LJ and bonded
types (which are the only ones absolutely needed).
  </li>
  <li>
Next, edit "<a href="../source/mod_aminos.f90">mod_aminos.f90</a>". Increase MAXAMINO accordingly and
append the arrays amino (three-letter code to be used), aminopolty
(whether bona fide polypeptide ('P'), polynucleotide ('N') residue or
whether anything else ('X')), and rescontlen (a reasonable diameter for
small molecules or the contour length for polymer residues). The variable
seqtyp defined in "<a href="../source/mod_sequen.f90">mod_sequen.f90</a>" will during runtime hold
- for each residue in the system - the index into these arrays. This is 
occasionally used to identify a residue by an integer number. 
  </li>
  <li>
Following up on this, another very simple step for a new new polymer residue is
to tell the wrapper-routine makepept() in "<a href="../source/makepept.f90">makepept.f90</a>"
that this residue with its new, unique index is a valid chain-residue. makepept() compares
in two more or less identical loops the values of a variable called sickle and of seqtyp(i), respectively,
to hard-coded ranges permissible to support the residue in specific positions (N-terminal,
C-terminal, or non-terminal). These conditionals (ranges) will have to be appended accordingly. 
  </li>
  <li>
Now comes one of the difficult steps: actually building the geometry of
the molecule / residue. Depending on the intended application, find
force field parameters or (usually preferred) high-resolution
crystallographic information on the intrinsic geometry of the residue
(except rotatable bonds). You are explicitly providing Z-matrix
information here, so it may not be as easy as anticipated (and require
a fair amount of trial and error). If a file with example Cartesian coordinates
is available, it may be easier to explicitly generate a Z-matrix first 
(<i>e.g.</i>, using CAMPARI by reading in the residue as an unsupported one) and 
to then transfer values.
In general the Z-matrix format references back a new atom i1 to three
previously built ones i2, i3, i4. i1 is directly bound to i2 which is
directly bound to i3 which is directly bound to i4. i1, i2, and i3 form
a well-defined bond angle. Beyond that there are three alternative
formats: first, i1, i2, and i4 may form a second bond angle which in
addition then employs a chirality indicator to distinguish two
otherwise indistinguishable placements. This is fully supported, but numerically
problematic (to be avoided). Second, i1, i2, i3, and i4 may
form a proper dihedral angle. This is the recommended case for the first atom
connected to the second atom of a chemical bond. Third, i1, i2, i3, and i4 may
form an improper dihedral angle (i2 is covalently bound to all other atoms). This is the
recommended setup for further atoms connected to the terminal atom of a chemical bond.
The chirality indicator is zero for both the second and third cases.
The Z-matrix is populated by calls to z_add(bio_type,r2,r3,r4,i2,i3,i4,chirality)
in "<a href="../source/topology.f90">topology.f90</a>":<br/>
<div class="art-Block">
<div class="art-Block-body">
<div class="art-BlockContent-body">
<code>
z_add(bio_type,r2,r3,r4,i2,i3,i4,chirality)<br/>
<br/>
   bio_type  = Defines current atom (i1)<br/>
   i2        = The previously built atom to which i1 is connected<br/>
   i3        = A previously built atom to which i2 is connected<br/>
   i4        = A previously built atom to which i3 or i2 is connected<br/>
   r2        = The bond length between i2 and i1<br/>
   r3        = The bond angle between i1-i2-i3<br/>
   r4        = The dihedral angle (angle) between i1-i2-i3-i4 (i1-i2-i4)<br/>
   chirality = If 0, r4 = dihedral. If +/-1, angle between i1-i2-i4<br/>
 </code></div></div></div>

As stated, if chirality is zero, r4 is interpreted as the proper or improper dihedral angle i1, i2, i3, and i4. If
it is either +/-1, r4 is interpreted as the bond angle between i1, i2,
and i4. For the first three atoms in any new molecule, not all
references are available and zeros are passed to indicate this.<br/>
For a small molecule, add the new molecule in "<a href="../source/proteus.f90">proteus.f90</a>" in the first
major block that stands under the conditional control
<div class="art-Block">
<div class="art-Block-body">
<div class="art-BlockContent-body">
<code>
if ((rsmol(imol,2)-rsmol(imol,1)).eq.0) then
 </code></div></div></div>
which simply implies that the molecule has only a single residue. For a canonical polypeptide
residue add a block in subroutine sidechain() in "<a href="../source/sidechain.f90">sidechain.f90</a>" and for
a canonical polynucleotide residue add a block in nuc_sidechain() in
"<a href="../source/sidechain.f90">sidechain.f90</a>". You will note
that residues are either identified by their name (in a variable often called resname; this is for better readability only),
their residue type index (the aforementioned seqtyp), or a coarser classification into polymer
types (the aforementioned "aminopolty" that takes the residue typ as index). Note that other useful
arrays are not yet populated ("seqflag" or "seqpolty") when these routines are called. For a polymer
residue, conditionals will have to appended throughout in "<a href="../source/proteus.f90">proteus.f90</a>"
to ensure that the new residue is available in all positions within the polymer. For example,
non-terminal polypeptide residues are screened for by the following conditional:<br/>
<div class="art-Block">
<div class="art-Block-body">
<div class="art-BlockContent-body">
<code>
    else if (((seqtyp(i).ge.1).AND.(seqtyp(i).le.25)).OR.&amp;<br/>
 &amp;          ((seqtyp(i).ge.31).AND.(seqtyp(i).le.35)).OR.&amp;<br/>
 &amp;          (seqtyp(i).eq.51)) then<br/>
 </code></div></div></div>
Such a conditional allows only residues with seqtyp-values in the indicated ranges to
be built in the middle of a polypeptide chain. A new polypeptide residue will have values
outside of these ranges, thereby requiring the extension.<br/>
Also for polymer residues, you may note the local data arrays
in both "<a href="../source/proteus.f90">proteus.f90</a>"
and "<a href="../source/sidechain.f90">sidechain.f90</a>" (such as "ntyp") which hold biotype
indices. A correct entry for a new polymer residue is crucial since
otherwise the wrong biotype and hence the wrong parameters may be used.
Aside from calling z_add as many times as necessary while passing along
the right geometry information (utilize arrays bo, an, and dh for
this), several arrays or indicators must be set manually:
    <br/>
    <ol>
      <li> Increment the arrays at(rs)%bb and at(rs)%sc and the
corresponding counters at(rs)%nbb and at(rs)%nsc. Here, "rs" is the
residue number (usually "i" in "<a href="../source/proteus.f90">proteus.f90</a>"
and "<a href="../source/sidechain.f90">sidechain.f90</a>"). Note
that the first atom in a residue or small molecule should always be a
backbone one and that branched mobile groups have to be in sc-arrays.
The second condition mentioned is naturally irrelevant for small molecules but
crucial for polymeric residues (never append at(rs)%bb within
sidechain.f90). For adding a canonical polypeptide or polynucleotide
residue, you should therefore <i>not</i> have to touch at(rs)%nbb and
at(rs)%bb.</li>
      <li>
Populate the pointer arrays for degrees of freedom. This is very
important for giving the residue access to dedicated move sets in Monte Carlo,
but also has relevance in internal coordinate space dynamics
(see <a href="keywords.html#TMD_UNKMODE">FMCSC_TMD_UNKMODE</a>). There are
pointer structures that can be incremented (nchi+chiline and
nnucs+nucline) and those that cannot (fline+fline2, yline+yline2,
wline). In the construction of sidechains and small molecules, it is
strongly advised to only use the nchi and chiline construct although
exceptions exist (see for example &omega;-sampling using wline in the
small molecule amides NMF and NMA). As you can see from inspecting the
code, the initial values for those degrees of freedom are already held
in their respective pointer arrays (for example "chi"). They are
initialized elsewhere (in subroutine makepept() in "<a href="../source/makepept.f90">makepept.f90</a>") and
can be adjusted there if special, initial values are required. </li>
      <li>
Populate the array eqatm if necessary. This array holds information
about rigidity within the molecule, <i>i.e.</i>, whether there are
non-rotatable dihedral angles or rigid ring systems. It generally works
best by assigning that prior atom which is the nearest to the mobile
parts to all downstream atoms which are connected rigidly to that atom.
For example, in the histidine sidechain, atoms CE1 and HE1 always have
atom ND1 set as their equivalent atom in equatm. This
implies that (for certain interaction models) they are going to be
treated just like the nitrogen atom in determining excluded
interactions. In this case, for example, the CG-to-HE1 interaction would be excluded
on account of the eqatm setting, even though those atoms are separated
by three bonds and hence would interact if flexibly connected.
      </li>
      <li>
Populate the array atmres which is simply a residue number per atom
array.
      </li>
      <li>
For polymers, certain prominent atoms along the main chain have their
own pointer arrays (for example ni, cai, ...). These will not usually
be required for building small molecules or new canonical residues of a
supported polymer type.
      </li>
      <li>
For all of the above, it is important to be mindful of the ua_model
flag (user-controllable through keyword <a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a>)
that chooses between different united-atom representations (non-polar
hydrogen atoms are not represented explicitly) and all-atom representation (see below).
      </li>
    </ol>
This concludes the necessary groundwork to allow CAMPARI to build the new unit.
Further modifications are needed to extend the functionality (some of it essential) the new residue or
molecule is supposed to cover.
  </li>
  <li>
A further essential step is to set the reference atom and sequence flag setting for the
residue / molecule. This is trivial and done in subroutine
absinth_residue() in "<a href="../source/assignprm.f90">assignprm.f90</a>". The reference atom ("refat") is used to
identify roughly the center of the unit for either just topology- or
grid- and topology-based cutoffs. The sequence flag ("seqflag") is used to group residues
into classes, <i>e.g.</i>, regular polypeptide residue <i>vs.</i> proline-like residue, <i>etc.</i>
  </li>
  <li>
With the geometry of the new residue and its reference atom cast in stone now, another simple step
is to append the subroutine setup_resrad() in "<a href="../source/structure.f90">structure.f90</a>" which populates arrays
for two variables. The first is the effective residue radius (defined as the maximum possible
distance measured from any atom to the residue's reference atom). The second
is the maximally expected number of atoms in that residue. In most cases, this 
will simply be the actual number of atoms. Note, however, that through conditions
for termini in polymeric residues and through future extensions pertaining to titratable
sites, the number is in some cases variable. The value specified here has to be the rigorous
<i>upper limit</i>. Outside of wasted memory and minute efficiency drawbacks,
it will not be harmful to specify something too large here.
  </li>
  <li>
The setup of <i>possible</i> degrees of freedom for MC and TMD calculations is generally 
automatic. If you accidentally set one of the pointers (fline, <i>etc.</i>) to an ineligible
Z-matrix line, subroutine find_rotlsts(...) should identify this problem and exit with an error.
This subroutine flags all dihedral angles that seem to correspond to freely rotatable
ones by allocating a rotation list (list of atoms moving as a result of perturbation to the
dihedral angle assuming the default building direction). This can be probed quickly 
by checking whether izrot(i)%alsz is larger than zero ("i" being the atom index in question). The only
other atoms for which this condition is true are the very first atoms in each molecule (they hold
a trivial rotation list for rigib-body rotation). All setup for TMD runs (dealing with
effective building direction, recursive computation of torsional gradients, ,<i>etc.</i>) should work
without additional code modifications.
  </li>
  <li>
If permanent support is needed for the ABSINTH implicit solvation model (rather
than using patches such as <a href="inputfiles.html#FMCSC_FOSPATCHFILE">solvation group patches</a>), a number
of additional steps are involved. It may take some time to get familiarized
with the data structures employed, so the learning curve may be a bit steeper
than for other modifications:
    <ol>
      <li>
The new sidechain and/or small molecule needs to be analyzed: is their
a corresponding, chemically well-defined model compound for which
transfer free energies have been determined experimentally? If no
experimental data are available, are there <i>in silico</i> estimates
available or possible to attain? It is important to note that the
ABSINTH paradigm rests somewhat on the assumption that the polymer is
modular and that the linkages between the model compounds are not
dominant solvation sites themselves. As an example, it would be
misleading to break up an ether at the oxygen atom and to use the
aliphatic substituents as the two model compounds.
      </li>
      <li>
With numbers and a satisfactory decomposition in mind, the next step is
to add a global variable in "<a href="../source/mod_fos.f90">mod_fos.f90</a>" and the facility to read and
report this value in "<a href="../source/readprm.f90">readprm.f90</a>". These are trivial extensions of the
subroutines read_fos() and fos_summary(). It is also recommended to add
the values in all of the parameter files distributed with the software
right away since the code does not warn about missing free energy of solvation (FOS) parameters.
Remember that for polymers, the specific entries only address the
variable parts, <i>i.e.</i>, the sidechains. For example, if FOS_ALA in the
parameter file is set to 1.9, then this is meant to be interpreted as
the FOS of the alanine sidechain model compound, <i>i.e.</i>, methane
(although the code can handle this flexibly: see below).
      </li>
      <li>
Next, open "<a href="../source/sav.f90">sav.f90</a>" and append subroutine setup_freesolv(). This is
trivial: note that the array freesolv has room for only three values per
residue (corresponding to the (maximum of three) numerical values on a single input line in the
<a href="parameters.html#S4_Free_energies_of_solvation">parameter file</a>.
This array simplifies coding later, but is not used beyond setup
tasks. The next major step is adding a section in the helper routines to
subroutine solvation_groups(). This populates the solvation group data
structure (see "<a href="../source/mod_polypep.f90">mod_polypep.f90</a>"). For small molecules, an entry is
needed in subroutine helper_svgrps_single() and for polymer residues
one in helper_svgrps_scpep() or helper_svgrps_scnuc(). Note that we
assume the polymer residues fit into the pre-existing backbone
paradigms flawlessly (as a counterexample, a polynucleotide residue with a
modified sugar would require further modifications). Check a simple
entry in helper_svgrps_single() to get a feel for the data structure,
and then implement the decomposition accordingly. You basically
have to define groups of atoms that form solvation groups on the unit you added 
(in the simplest case, this can be just a single group). Note that sometimes
an experimentally available number is further decomposed if the unit
is intrinsically asymmetric. The tyrosine sidechain - for example - has a benzene-like part and a polar part,
which actually form separate solvation groups. This may create subtle parameter
interdependencies (in this case, the resultant FOS value for a tyrosine sidechain
in a specific conformation of a polypeptide would depend weakly on the value used for benzene
in the parameter file; this is because the two actual solvation groups derived from the entries for tyrosine and benzene
will be different). Conversely, for fully solvated states, the sum of all values
should always yield the desired reference FOS.
     </li>
      <li>
While it may seem as if this should be enough, there is one more major step
involved, which does nothing but set the parameters in the array atsavmaxfr.
These values are the fractions of solvent-accessible volume remaining
after those of the atoms belonging to the same model compound have been
subtracted. In theory, for fixed size and solvation parameters and fixed initial
geometry, it is possible to compute these only once and to simply hard-code the values
or read them from a file. The subroutine setup_savol() and its daughter
routines in "<a href="../source/sav_auxil.f90">sav_auxil.f90</a>" do this dynamically at the beginning of each
simulation. The process is three-fold: i) for each model compound,
build any necessary dummy atoms (usually aliphatic hydrogens on
aliphatic C-connectors); ii) assemble the list of atoms belonging to
the model compound (this can be tricky if atoms are shared such as
along the polypeptide backbone by consecutive NMA units); iii) run a
pairwise loop over the complete list and determine volume reductions to
be captured by atsavmaxfr. For small molecules, this is trivial as seen
in subroutines gen_complst_bb() and gen_dummyH_bb() in "<a href="../source/sav_auxil.f90">sav_auxil.f90</a>".
For novel peptide or polynucleotide residues, this can be relatively
easy if analogy coding is used (especially with respect to the
generation of the few necessary dummy hydrogens): see subroutine
gen_all_sc()). For a completely new polymer or backbone modifications,
this would be much more cumbersome. It is definitely worthwhile to
check the values obtained for atsavmaxfr, which can be written out by
turning on <a href="keywords.html#SAVCALC">SAV-analysis</a> (written
to <a href="outputfiles.html#SAV_BY_ATOM.dat">SAV_BY_ATOM.dat</a>).
     </li>
    </ol>
  </li>
  <li>
To support polar interactions, the only things needed are to assign
charge types in the parameter file and to append any appropriate
conditionals in subroutine polar_groups() in "<a href="../source/polar.f90">polar.f90</a>"
(usually none, as seqflag is used for parsing). In some cases,
certain parameterization paradigms and/or molecular architectures
require specific exclusion rules or adjustment of parameters. As
outlined above, exclusions are generally handled via the eqatm
construct. This can be seen for polar interactions in the latter half
of subroutine polar_groups() and for other non-bonded interactions in
subroutine setup_srinter() in "<a href="../source/unbond.f90">unbond.f90</a>".
In general, modifications should not be necessary if eqatm is populated correctly.
Developers may note that there is an automatic treatment available for unsupported residues 
(uses subroutine ia_rotlsts(...) in "<a href="../source/topology.f90">topology.f90</a>"), which
can theoretically be used also for built-in residues (if the eqatm treatment appears
infeasible). There are further exceptions: the GROMOS
force field uses its own set of rather obscure excludes (see <a
 href="keywords.html#INTERMODEL">FMCSC_INTERMODEL</a>). For
compatibility, CAMPARI has two subroutines (GROMOS_excludes_polar() in
"<a href="../source/polar.f90">polar.f90</a>" and GROMOS_excludes()
in "<a href="../source/unbond.f90">unbond.f90</a>"), which may need to be
appended. CHARMM on the other hand uses pre-polarized charges on the
two hydrogens in primary amides (<i>cis</i> vs. <i>trans</i>) which have the same
biotype in CAMPARI. A special rule to support this paradigm is found in
polar_groups() (see <a href="keywords.html#AMIDEPOL">FMCSC_AMIDEPOL</a>)
and may need to be appended as well.
  </li>
  <li>
If you have gotten this far, this is a good time to append the documentation, specifically
that on <a href="inputfiles.html#FMCSC_SEQFILE">sequence input</a>. If there are
any special considerations for samplers or analysis routines, you should insert them 
into the documentation. If not done already, it would also be very useful to
append <i>all</i> nonobsolete parameter files distributed with the code.
  </li>
  <li>
From here on, the major part of the work consists of making sure that
everything works as intended. CAMPARI utilizes plenty of conditionals
checking for residue identity through the array seqpolty, through the
arrays seqflag and seqtyp, through the presence of positive entries pointer arrays
(such as fline, wline, ...), or (rarely) through the residue name via the array
aminos. If the new unit/residue is supposed to work just like another
existing case for some of the code's functionality, then it will often
be necessary to append the corresponding conditionals. This is best
illustrated using an example: suppose you added a non-canonical
polynucleotide residue with identical backbone architecture, for
example 5-methylcytosine. Then, conditionals which test for seqpolty
being 'N' or for seqflag being 22/24 will be unaffected as will be those testing for the pointer
arrays nucsline. Conversely, the remaining checks require code modifications 
(at the very least: appending conditionals). CAMPARI has been evolved to become
more and more developer-friendly in this regard, <i>i.e.</i>, the goal
is that all the required changes in the code actually correspond to 
conscious decisions regarding the new residue, and that all things that should
work automatically do in fact work automatically.
  </li>
  <li>
One of the more important auxiliary things to fully support a new
residue or small molecule is to enable pdb-structures to be written and
read-in correctly. The former is simple. If special names are
required (compared to those in the biotype section of the parameter
file), the output strings for atom names may need to be adjusted. This
is done in routines name_heavies() and name_hydrogens() in "<a href="../source/prtpdb.f90">prtpdb.f90</a>".
Reading from pdb requires more work. The first thing to do be to
consider whether the new unit has any common ambiguities with respect to
its pdb atom names which can be corrected upfront in subroutine
pdbcorrect() in "<a href="../source/readpdb.f90">readpdb.f90</a>". The only thing to watch out for here is
the structure of the conditionals. Beyond that, there are three modes for
reading in a pdb-file (see <a href="keywords.html#PDB_READMODE">FMCSC_PDB_READMODE</a>).
Options 2 and 3 (the defaults for trajectory analysis and simulation tasks, respectively) both use
xyz-coordinates in the pdb directly. In the absence of exceptions, extending
this functionality to support the new residue type is simple. For a small molecule, the subroutine trf_sms()
needs to be appended, for new polynucleotide or polypeptide residues,
it is just trf_scs() to add support for reading in the novel sidechain.
These routines are generally trivial to append. Possible exceptions in dealing with PDB 
input are the shifting of atoms to a neighboring residue because of convention (as for <a href="keywords.html#PDB_NUCMODE">PDB_NUCMODE</a>,
this should be avoided at all cost), problems with duplicate atom names (CAMPARI will crash if the names are not unique),
andf the use of wild card residue names (as for distinguishing deoxyribo- from ribonucleotides or as for 
supporting the residue name "HIS" in PDB files). If the new residue warrants any of these exceptions,
you will alos need to modify subroutine "FMCSC_readpdb2" &rarr; search for the string "HIS"
in this subroutine to see an example.
  </li>
  <li>
The first option for <a href="keywords.html#PDB_READMODE">FMCSC_PDB_READMODE</a> is considered largely obsolete.
You could therefore simply add a call to "fexit" with an error message in a subroutine like
"readpdb1_chi" in "<a href="../source/readpdb.f90">readpdb.f90</a>" and skip to the next point.
This PDB parsing mode extracts CAMPARI's internal list of MC degrees of freedom but keeps CAMPARI's
built-in geometries as follows:
    <ol>
      <li>
Through some pre-parsing, the file is read and residues are identified
(which is why residue numbering has to be proper). Each residue block
is scanned for specific atom names assigned in readpdb1_collect() along
with an indicator variable ("ok") that a certain name was found.
      </li>
      <li>
For each molecule, the code attempts to extract the rigid-body
coordinates which are simply fixated by the positions of the first
three atoms. The code balks if this fails which happens in subroutine
readpdb1_rbs().
      </li>
      <li>Next, the sidechain angles are extracted in subroutine
readpdb1_chis(). Here, it is important to know which reference atoms
each dihedral degree of freedom uses in order to ensure that the
correct value is assigned. The four relevant positions (if found) are
then passed to subroutine dihed() which calculates the dihedral angle
which is subsequently assigned to the appropriate pointer array (such
as chi).
      </li>
      <li>After this, backbone angles are extracted through two
subroutines (readpdb1_omegas(), which is hardly relevant, and
readpdb1_bbs()). Lastly, some of the presence indicators are shifted so
that knowledge of some positions of atoms in prior residues is carried
through to the next one. None of this should be relevant if one is
adding just a new small molecule or a canonical residue.
      </li>
    </ol>
Given this rough overview, the necessary modifications in
readpdb1_collect(), readpdb1_rbs(), and readpdb1_chis() should again be
trivial to undertake. More than anything else, the pdb-writing and
-reading facilities are just cumbersome.
  </li>
  <li>
Lastly, if one can think of any circumstances under which the new unit
could cause problems that are not already covered by the existing sanity
check machinery, it will provide useful to implement additional
high-level sanity checks (in "<a href="../source/sanity_checks.f90">sanity_checks.f90</a>") which disable the
respective features upon encountering the new residue or molecule. Such
holes are best identified by trying to run a few calculations with the
new group which attempt to utilize all of CAMPARI's functionality (all
analysis flags small, all running output enabled, different samplers,
...).
  </li>
  <li>
As an additional comment: you may have noticed that CAMPARI
alternatively builds things internally in AA- or UA-representation (see
    <a href="keywords.html#UAMODEL">FMCSC_UAMODEL</a>). This can lead
to plenty of shifts in atomic arrays or even torsional degrees of
freedom (for example for ethanol or <i>p</i>-cresol) which may require adding
conditionals reflecting those shifts. These occur in a wide variety of
places. In this context it is useful to know that a <i>de facto</i> UA
model can always be set up through the parameter file even though the
molecules are built in AA representation. This works fine (and hence UA
modifications are not required even if the force field is UA) but is
inefficient - hence the explicit (and cumbersome) UA support.
  </li>
</ol>
<br/>
<br/>
<b>Q: What do I need to do and know if I want to include a custom
analysis routine?</b>
<br/>
<b>A</b>: This is generally simple unless the custom analysis routine itself is complicated and/or 
computationally expensive. As always, a decent knowledge of the CAMPARI data
structures. For quick hacks, there is usually no need to worry about parallelization
(whether shared- or distributed memory), but for permanent merging there is of course.
<ol type="A">
  <li>First, decide which new global variables are needed and add them
(preferably) in an existing module that deals with similar quantities
(e.g., "<a href="../source/mod_polyavg.f90">mod_polyavg.f90</a>" or "<a href="../source/mod_torsn.f90">mod_torsn.f90</a>"). If necessary, initialize the
non-allocatable variables in "<a href="../source/initial.f90">initial.f90</a>". Make sure memory of the
requisite size is allocated for allocatable variables. This should but
- especially for temporary code modifications - must by no means happen
in "<a href="../source/allocate.f90">allocate.f90</a>". It is recommended to maintain the existing structure
in "<a href="../source/allocate.f90">allocate.f90</a>", <i>i.e.</i>, there are many allocation blocks controlled by
an individual subroutine which contains creators (including
initialization) and destructors. Conditional controls are generally
applied (where necessary) to prevent unneeded memory from being
allocated. As an example, have a look at subroutine allocate_polyavg().
  </li>
  <li>
For permanent analysis routines, the next step would be to provide the
user interface for controlling the analysis, <i>i.e.</i>, to add keywords and
their read-in statements in "<a href="../source/parsekey.f90">parsekey.f90</a>". This usually works without
much thought by appending any of the lists in a suitable helper
subroutine. Copy a block which reads in a keyword assigning a variable
of identical dimension and data type and then simply edit the details
(make sure to match the length of the substring of keyword correctly and do
not delete the assignment of "have_legit_key" to true &larr; otherwise your
keyword will be incorrectly reported as unrecognized).
Note, however, that the main subroutine parsekey() is called several
times with different flags for the hierarchy level being passed. These are needed if and
because keywords depend on each other, <i>i.e.</i>, require a conditional
assignment (for example, the code needs to know first whether the
simulation system is a cubic box or a sphere before it can decide
whether to read in three or just one number for the size
specification). For temporary modifications to facilitate specific
analyses, these modifications are usually more time-consuming than to
modify the code directly and hard-code the settings.
  </li>
  <li> Almost all analysis routines are called from subroutine mcstat() in
"<a href="../source/mcstat.f90">mcstat.f90</a>". In general, each analysis
functionality has two subroutines, one for collecting data during the
simulation or trajectory analysis run, and one for producing the final result.
Because analysis may be the dominant CPU time cost of a given run, the 
<a href="keywords.html#NRTHREADS">OpenMP shared-memory parallelization</a>
has to address it. This currently happens in one of two ways: either the analysis
code is serial and dealt with by an individual thread (there are two large 
OpenMP SECTIONS directives for this), or the analysis code is itself OpenMP-parallelized
and the function is called by all threads (see for example the call
to "do_em_density_map(tpi)" in "<a href="../source/mcstat.f90">mcstat.f90</a>" with
the actual function found in "<a href="../source/emicroscopy.f90">emicroscopy.f90</a>").
The former scenario is of course much simpler to handle (no writing of parallel code required)
while the latter is recommended only for analyses that scale poorly with system size.
For a block added into one of the SECTIONS directives, simply copy an
existing block, <i>e.g.</i>, the one calling "do_rama". You will see that the
call to an analysis routine only happens every so often (the mod(istep,???calc) construct accomplishes that).
Thus, if the functionality is to be added permanently, ???calc should be a global
frequency variable you created. A second subroutine invocation, <i>viz.</i>, to the one
producing the final output, should be added if necessary. For this, find the block under the
control statement "if ((istep.eq.nsim).AND.(nsim.gt.nequil)) then"
which simply means that the last step of a simulation (or analysis run)
is reached (in which not all steps were discounted as equilibration).
There are two such spots (see for example the calls to "printrama"), one for MPI code
with rank-separate analyses, and one for non-MPI code. There are no 
OpenMP concerns here, since the block is currently in an OpenMP MASTER 
directive.
  </li>
  <li>
Write the analysis subroutine. To keep things simple, use an existing
source file with similar scope such as "<a href="../source/structure.f90">structure.f90</a>", "<a href="../source/polymer.f90">polymer.f90</a>", or
"<a href="../source/torsion.f90">torsion.f90</a>". Study a few of the existing analyses to get familiar with
some of the data structures, which allow you to access information
about the system (for example, x,y,z for Cartesian coordinates found in
"<a href="../source/mod_atoms.f90">mod_atoms.f90</a>"; ztor, bang, blen for Z-matrix coordinates found in
"<a href="../source/mod_zmatrix.f90">mod_zmatrix.f90</a>"; pointer arrays to specific sites and/or degrees of
freedom found in "<a href="../source/mod_polypep.f90">mod_polypep.f90</a>" and "<a href="../source/mod_fyoc.f90">mod_fyoc.f90</a>", and so on ...).
Never forget to declare "implicit none" in a subroutine and to include
the needed modules. Make sure the interfaces you used in "<a href="../source/mcstat.f90">mcstat.f90</a>"
match those you create now. If you prefer to be neat, write explicit interfaces for 
all subroutines with "INTENT" statements for passed arguments; this helps the compiler
detect incorrect calls (currently, CAMPARI uses interfaces only where required, and they are collected in
a single module: "<a href="../source/mod_interfaces.f90">mod_interfaces.f90</a>").  
For a specific but simple example, study
do_rbc_pc() and prt_rbc_pc() in "<a href="../source/structure.f90">structure.f90</a>": these subroutines
compute distance distribution functions between molecular centers of
mass and print the results to a file called RBC_PC.dat (for MPI-unaware or <a href="keywords.html#MPIAVG">MPI averaging</a> runs)
or N_XYZ_RBC_PC.dat (<a href="keywords.html#REMC">MPI rank-separated analyses/runs</a>). The rest is up to you!
  </li>
  <li>
If your analysis is meant to work with <a href="keywords.html#MPIAVG">MPI averaging calculations</a>,
there is an additional step. The functions MPI_AVGCollect() and
MPI_AVGSend() in "<a href="../source/fmsmcmpi.f90">fmsmcmpi.f90</a>" handle the transfer of information from
the harvesting ranks (which call MPI_AVGSend()) to the master rank
(which is the only one to call MPI_AVGCollect()). If you are unfamiliar
with MPI programming, you may want to read up on it a little bit.
What is needed is very simple, though: the globals in which each rank
collected information while executing the custom analysis routine must
be collected and combined. For this, we pass specific messages of
specific size in specific order from the slaves to the master. The
aforementioned subroutines are straightforward to extend, but the
following must be kept in mind: i) all conditional controls in both subroutines must be
identical, ii) all message codes (integers) in both subroutines must be
identical, iii) whenever passing a message, the size and data type of
the message must match the passed variable exactly, iv) if the analysis
requires a separate normalization / print-out call, this subroutine
must be called from within MPI_AVGCollect() but (obviously) after
combining the data from all the ranks.
  </li>
  <li>
If you coded your analysis routine with explicit 
<a href="keywords.html#NRTHREADS">OpenMP support</a>, it may be useful
to add a test for it. Have a look at subroutine "threads_test"
in "<a href="../source/thread_utils.f90">thread_utils.f90</a>" for 
reference (this routine is executed only when keyword
<a href="keywords.html#THREADS_TEST">FMCSC_THREADS_TEST</a> is set to 1.
The idea is simply to run through a sequence of unit-like tests 
using serial execution of the same (or functionally equivalent) code on the same but
dynamically generated data sets for comparison. Adding a test can be very useful
in excluding (or finding) specific parallel programming bugs as sources of error later on.
  </li>

</ol>
</div>
</div>
</div>
</div>
<!-- Side Navigation Bar --><!--<div class="art-sidebar1">--><!-- Contributors Block --><!--<div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Contributors - Links</div>
                            </div>
                        </div><div class="art-BlockContent">
                            <div class="art-BlockContent-body">
                                <div>
                                <b>Pappu Lab</b><br />
                                Washington University in St. Louis, MO<br />
                                Website: <a href="lima.wustl.edu">lima.wustl.edu</a><br />
                                Phone: (999) 999-9999 <br/>
                                <br/>
                                <b>Andreas Vitalis</b><br />
                                Unistat de Zurich<br />
                                Website: <a href="papajohns.com">vitalis.net</a><br />
                                Phone: (111) 999-9999 <br/>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>--><!-- Search Block --><!--
                <div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Find Text</div>
                            </div>
                        </div><div class="art-BlockContent">
                            <div class="art-BlockContent-body">
                                <div><form method="get" id="newsletterform" action="javascript:void(0)">
                                <input type="text" value="" name="email" id="s" style="width: 95%;" />
                                <span class="art-button-wrapper">
                                    <span class="l"> </span>
                                    <span class="r"> </span>
                                    <input class="art-button" type="submit" name="search" value="Search"/>
                                </span>
                                </form></div>
                            </div>
                        </div>
                    </div>
                </div> 
                --><!-- News/Updates Block --><!--
                <div class="art-Block">
                    <div class="art-Block-tl"></div>
                    <div class="art-Block-tr"></div>
                    <div class="art-Block-bl"></div>
                    <div class="art-Block-br"></div>
                    <div class="art-Block-tc"></div>
                    <div class="art-Block-bc"></div>
                    <div class="art-Block-cl"></div>
                    <div class="art-Block-cr"></div>
                    <div class="art-Block-cc"></div>
                    <div class="art-Block-body">
                        <div class="art-BlockHeader">
                            <div class="l"></div>
                            <div class="r"></div>
                            <div class="art-header-tag-icon">
                                <div class="t">Recent News</div>
                            </div>
                        </div><div class="art-BlockContent">
                            <div class="art-BlockContent-body">
                                <div>
                                    <p><b>Jun 14, 2008</b><br/>
                                    Aliquam sit amet felis. Mauris semper, 
                                    velit semper laoreet dictum, quam 
                                    diam dictum urna, nec placerat elit 
                                    nisl in quam. Etiam augue pede, 
                                    molestie eget, rhoncus at, convallis 
                                    ut, eros. Aliquam pharetra.<br/>
                                    <a href="javascript:void(0)">Read more...</a></p>
                                                          
                                    <p><b>Aug 24, 2008</b><br/>
                                    Aliquam sit amet felis. Mauris semper, 
                                    velit semper laoreet dictum, quam 
                                    diam dictum urna, nec placerat elit 
                                    nisl in quam. Etiam augue pede, 
                                    molestie eget, rhoncus at, convallis 
                                    ut, eros. Aliquam pharetra.<br/>
                                    <a href="javascript:void(0)">Read more...</a></p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div> --><!-- End Sidebar --> </div>
</div>
</div>
<!-- End main page contents --><!-- Footer -->
<div class="art-Footer">
<div class="art-Footer-background">
<div class="art-Footer-inner"> <a href="#" class="art-rss-tag-icon"
 title="RSS"></a>
<div class="art-Footer-text">
<p><a href="#">Contact Us</a> | <a href="#">Terms of Use</a> | <a
 href="#">License Information</a><br/>
Copyright  2010 . All Rights Reserved.</p>
</div>
</div>
</div>
</div>
<p class="art-page-footer">XHTML and CSS valid. Powered by <a
 href="http://www.flashmint.com/">FlashMint</a> - flash templates
provider.</p>
<div style="text-align: center; font-size: 0.75em;">Design downloaded
from <a href="http://www.freewebtemplates.com/">free website templates</a>.</div>
</div>
</body>
</html>
